---
title: "Programming with dplyr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Programming with dplyr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
set.seed(1014)
```

The dplyr verbs `arrange()`, `filter()`, `group_by()`, `mutate()`, `slice()`, and `summarise()` all use **tidy evaluation**. Tidy evaluation is a speical type of non-standard evaluation used throughout the tidyverse. One of the benefits of tidy evaluation is that it provides **data masking** which blurs the lines between variables in the environment and variables in the dataset. 

(`across()`, `select()`, `rename()`, and `pull()` use **tidy selection**, which we'll come back to later.)

Data masking allows your data manipulation code to be more succinct because you don't need to repeat the name of the data frame. For example, you can write `filter(df, x == 1, y == 2, z == 3)` instead of `df[df$x == 1 & df$y ==2 & df$z == 3, ]`. Unfortunately this benefit does not come for free. It's harder to use  indirection: how do you store the "name" of variable inside another variable so you can write a function or for loop? Fortunately, dplyr provides tools to overcome these short comings, which you'll learn in this vignette. We'll start with some important vocab, and then dive into a bunch of applications.

```{r, message = FALSE}
library(dplyr)
```

## Key ideas

### The two meanings of "variable"

The key of data masking which blurs the line between two meanings of "variable":

* __env-variables__ are "programming" variables that live in an environment.
  They are usually created with `<-`. 

* __data-variables__ are "statistical" variables that live in a data frame.
  They usually come from data files (e.g. `.csv`, `.xls`), or are created 
  manipulating existing variables. 
  
Take this piece of code:

```{r}
df <- data.frame(x = runif(3), y = runif(3))
df$x
```

It creates a env-variable called `df`, that contains two data-variables, `x` and `y`. Then it extracts the data-variable `x` out of the data frame `df` using `$`.

Tidy evaluation makes it easier to write data analysis code because it blurs the distinction between the two types of variables, allowing you to refer to data-variables without any additional syntax. In most (but not all) base R functions you need to refer to a data-variable with `$`, leading to code that repeats the name of the data frame many times:

```{r, results = FALSE}
starwars[starwars$homeworld == "Naboo" & starwars$species == "Human", ,]
```

The dplyr equivalent of this code is more concise because you can refer to data-variables as if they were env-variables:

```{r, results = FALSE}
starwars %>% filter(homeworld == "Naboo", species == "Human")
```

(dplyr's `filter()` is inspired by base R's `subset()`. `subset()` provides data masking, but not with tidy evaluation, so unfortunately the same techniques don't apply to it.)

You usually use dplyr verbs purely with data-vars, but they work equally well with env-vars:

```{r, results = FALSE}
planet <- "Naboo"
starwars %>% filter(homeworld == planet)
```

I think this blurring of the meaning of variable is a really nice feature for interactive data analysis, because it allows you to refer to data-vars as is, without any prefix. And this seems to be fairly intuitive, since many newer R users will attempt to write `diamonds[x == 0 | y == 0, ]`. But when you start to program with these tools, you're going to have to grapple with the distinction. And this will be hard because you've never had to think about it before, so it'll take a while for your brain to learn these new concepts and categories. However, once you've teased apart the idea of "variable" in data-variable and env-variable, I think you'll find it fairly straightforward to use.

### The two forms of indirection

The main challenge of data masking arises when you introduce some indirection, i.e. instead of directly typing the name of a variable you want the user to supply it in a function argument or character vector.

*   If you want the user to supply the variable (or function of variables)
    in an argument to your function, **embrace** the argument by surrounding
    it in doubled parentheses, e.g. `filter(df, {{ var }})`.

    ```{r, results = FALSE}
    dist_summary <- function(df, var) {
      df %>%
        summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
    }
    mtcars %>% 
      group_by(cyl) %>% 
      dist_summary(mpg)
    ```

*   If you have the column name as a character vector, index into 
    the `.data` pronoun with `[[`, e.g. 
    `summarise(df, mean = mean(.data[[var]]))`.

    ```{r, results = FALSE}
    for (var in names(mtcars)) {
      mtcars %>% count(.data[[var]]) %>% print()
    }
    ```

### Action vs selection

### The theory

This document is refrains from discussing the underlying theory of tidy evalauation. Thanks to recent improvements in the syntax (particularly the introduction of `{{ }}`), there are very few places that the theory helps you in day-to-day data science problems. However, if would like to go into the details, the best place are the Metaprogramming chapters in [_Advanced R_](https://adv-r.hadley.nz).

## How tos

Now that you have the key ideas of tidy evaluation under your belt, the remainder of this article focusses on how you can solve specific problems that you might encounter.

The examples here are somewhat inauthentic because we've reduced them down to very simple components to make them easier to understand. They're so simple that you might wonder why we bother writing a function at all. But it's a good idea to learn the ideas on simple examples, so that you're better prepared to apply them to the more complex situations you'll see in your own code.

### How to tell if a function uses tidy evaluation

To be more precise, tidy evaluation is a property that applies not to an entire function, but to arguments of a function. For example, the `.data` argument always uses standard evaluation, but the arguments in `...` usually use tidy evaluation. You can tell if an argument uses special evaluation because it will have special a label, `<tidy-eval>`, which links a shorter form of this vignette.

### Function with user-supplied data

You already know how to write functions that work with the first argument of
dplyr verbs: the data. For example, if you saw repeated code like this:

```{r, eval = FALSE}
mutate(df1, y = a + x)
mutate(df2, y = a + x)
mutate(df3, y = a + x)
mutate(df4, y = a + x)
```

You could already write a function to capture that duplication:

```{r}
mutate_y <- function(df) {
  mutate(df, y = a + x)
}
```

### Function with a user-supplied expression

```{r}
df <- tibble(
  g1 = c(1, 1, 2, 2, 2),
  g2 = c(1, 2, 1, 2, 1),
  a = sample(5),
  b = sample(5)
)

df %>%
  group_by(g1) %>%
  summarise(a = mean(a))

df %>%
  group_by(g2) %>%
  summarise(a = mean(a))
```

You might hope that this will work:

```{r, error = TRUE}
my_summarise <- function(df, group_var) {
  df %>%
    group_by(group_var) %>%
    summarise(a = mean(a))
}

my_summarise(df, g1)
```

But it doesn't because `group_by()` expects its inputs to be data-variables, and here you've given it an env-variable that contains a data-variable supplied by the user[^promise]. To make this function work, we need to tell `group_by()` that, but using `{{`:

[^promise]: Technically, this env-variable is a promise.

```{r}
my_summarise <- function(df, group_var) {
  df %>%
    group_by({{ group_var }}) %>%
    summarise(a = mean(a))
}

my_summarise(df, g1)
```

This generalises in a straightforward way if you want to use one user supplied expression in multiple places. For example, if you wanted to write a function to reduce the duplication here:

```{r}
df %>% summarise(mean = mean(a), sum = sum(a), n = n())
df %>% summarise(mean = mean(a * b), sum = sum(a * b), n = n())
```

You'd just use:

```{r}
my_summarise2 <- function(df, expr) {
  expr <- enquo(expr)

  df %>% summarise(
    mean = mean({{ expr }}),
    sum = sum({{ expr }}),
    n = n()
  )
}
df %>% my_summarise2(a)
df %>% my_summarise2(a * b)
```

### Function with multiple user-supplied expressions

If you just want to pass expressions along without transforming them, you can use `...`:

```{r}
my_summarise <- function(df, ...) {
  df %>%
    group_by(...) %>%
    summarise(a = mean(a))
}

my_summarise(df, g1, g2)
```
  
### Function with multiple user-supplied variables

If you want the user to provide a set of variables that are then transformed, use `across()`:

```{r}
my_summarise <- function(df, summary_vars) {
  df %>%
    summarise(across({{ summary_vars }}, mean))
}

my_summarise(df, c(g1, g2))
```

You can use this same idea for multiple sets of input variables:

```{r}
my_summarise <- function(df, group_by, summarise_by) {
  df %>%
    group_by(across({{ group_by }})) %>% 
    summarise(across({{ summarise_by }}, mean))
}
```

### Loop over multiple variables

If you want to loop over variables you need a slightly different approach, because precisely storing expressions in a vector requires greater knowledge of the underlying theory. A simpler approach is to put the variable names in a character vector and use the special `.data` pronoun:

```{r, eval = FALSE}
for (var in names(mtcars)) {
  mtcars %>% count(.data[[var]]) %>% print()
}
```

(Note that `.data` is not a data frame; it's a special construct that allows you to access the current variables either directly, with `.data$x` or indirectly with `.data[[var]]`. Don't expect other functions to work with it.)

### Use a variable from an Shiny input

Many Shiny input controls return character vectors, so you can use the same approach as above: `.data[[input$var]]`.

```{r, eval = FALSE}
library(shiny)
ui <- fluidPage(
  selectInput("var", "Variable", choices = names(diamonds)),
  tableOutput("output")
)
server <- function(input, output, session) {
  data <- reactive(filter(diamonds, .data[[input$var]] > 0))
  output$output <- renderTable(head(data()))
}
```

See <https://mastering-shiny.org/action-tidy.html> for more details and case studies.

### Eliminating the `R CMD check` `NOTE`

```{r}
my_summary_function <- function(data) {
  data %>% 
    filter(x > 0) %>% 
    group_by(grp) %>% 
    summarise(y = mean(y), n = n())
}
```

```
N  checking R code for possible problems
   my_summary_function: no visible binding for global variable ‘x’, ‘grp’, ‘y’
   Undefined global functions or variables:
     x grp y
```

```{r}
#' @importFrom rlang .data
my_summary_function <- function(data) {
  data %>% 
    filter(.data$x > 0) %>% 
    group_by(.data$grp) %>% 
    summarise(y = mean(.data$y), n = n())
}
```
